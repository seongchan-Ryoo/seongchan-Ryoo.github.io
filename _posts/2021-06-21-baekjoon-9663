---
layout: post
title: 백준 9663 N-Queen
author: "seongchan-Ryoo"
tag: [Problem, bruth force]
---
# 백준 9663 N-Queen

https://www.acmicpc.net/problem/9663

크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.
백준의 문제 중, 숫자의 나열을 모든 경우의 수에 따라 배열하는 문제가 있다.
이 문제 또한 그와 유사하다.
모든 경우의 수에 대해, 현재까지 주어진 퀸이 서로 공격할 수 없을 시, 다음 열에 배열하는 bruth force 문제이다.

```C++
#include <iostream>

using namespace std;

int N;
int result=0;

bool ch[16][16]={false,};

bool isSame(int r,int c){
	int r_n,c_n;
	for(int i = 1;i <= N; i++){
		if(i==r)
		 continue;
		
		if(ch[i][c]){
			return false;
		}
	}
	
	for(int i = 1;i <= N; i++){
		if(i==c)
		 continue;
		
		if(ch[r][i]){
			return false;
		}
	}
	
	for(int i = 1; i<=N; i++){
		r_n = r-i;
		c_n = c-i;
		if(r_n<=0 || r_n>N)
			break;
		if(c_n<=0 || c_n>N)
			break;
		if(ch[r_n][c_n]){
			return false;
		}
	}
	
	for(int i = 1; i<=N; i++){
		r_n = r+i;
		c_n = c+i;
		if(r_n<=0 || r_n>N)
			break;
		if(c_n<=0 || c_n>N)
			break;
		if(ch[r_n][c_n]){
			return false;
		}
	}
	
	for(int i = 1; i<=N; i++){
		r_n = r-i;
		c_n = c+i;
		if(r_n<=0 || r_n>N)
			break;
		if(c_n<=0 || c_n>N)
			break;
		if(ch[r_n][c_n]){
			return false;
		}
	}
	
	for(int i = 1; i<=N; i++){
		r_n = r+i;
		c_n = c-i;
		if(r_n<=0 || r_n>N)
			break;
		if(c_n<=0 || c_n>N)
			break;
		if(ch[r_n][c_n]){
			return false;
		}
	}	
	return true;
}

void check(int r){
	for(int c=1;c<=N;c++){
		if(isSame(r,c)){
			if(r==N){
				result+=1;
			}
			else{
				ch[r][c]=true;
				check(r+1);
				ch[r][c]=false;
			}
		}	
	}
	return;
}


int main(){
	cin>>N;

	check(1);
		
	cout<<result<<endl;
	
	return 0;	
	
}
```

